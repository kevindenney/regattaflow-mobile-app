/**
 * Sailwave BLW File Generator
 *
 * Generates .BLW (INI-style) files from RegattaFlow data for export to Sailwave.
 * Supports round-trip: import → modify → export without data loss.
 */

import {
  SailwaveData,
  SeriesConfig,
  EventConfig,
  ScoringConfig,
  Competitor,
  Race,
  RaceResult,
  BLWSection,
} from './BLWParser';

// ============================================================================
// Generator Class
// ============================================================================

export class BLWGenerator {
  /**
   * Generate BLW file content from structured data
   */
  generate(data: SailwaveData): string {
    const sections: string[] = [];

    // Header comment
    sections.push(this.generateHeader());

    // Series section
    sections.push(this.generateSeriesSection(data.series));

    // Event section
    sections.push(this.generateEventSection(data.event));

    // Scoring section
    sections.push(this.generateScoringSection(data.scoring));

    // Discard section
    sections.push(this.generateDiscardSection(data.discards));

    // Fleet sections (if any)
    for (const fleet of data.fleets || []) {
      sections.push(this.generateFleetSection(fleet));
    }

    // Division sections (if any)
    for (const division of data.divisions || []) {
      sections.push(this.generateDivisionSection(division));
    }

    // Competitor sections
    for (const comp of data.competitors) {
      sections.push(this.generateCompetitorSection(comp));
    }

    // Race sections
    for (const race of data.races) {
      sections.push(this.generateRaceSection(race));
    }

    // Result sections
    for (const result of data.results) {
      sections.push(this.generateResultSection(result));
    }

    // Preserve unknown sections for round-trip fidelity
    for (const section of data.raw || []) {
      sections.push(this.generateRawSection(section));
    }

    return sections.join('\n\n');
  }

  /**
   * Generate BLW content and return as a Blob for download
   */
  generateBlob(data: SailwaveData): Blob {
    const content = this.generate(data);
    return new Blob([content], { type: 'text/plain;charset=utf-8' });
  }

  /**
   * Generate a suggested filename for the BLW export
   */
  generateFilename(data: SailwaveData): string {
    const safeName = (data.event.name || data.series.name || 'export')
      .replace(/[^a-z0-9]/gi, '_')
      .replace(/_+/g, '_')
      .substring(0, 50);
    return `${safeName}.blw`;
  }

  // ==========================================================================
  // Private Methods - Section Generation
  // ==========================================================================

  private generateHeader(): string {
    const now = new Date();
    return `; Sailwave BLW file generated by RegattaFlow
; Generated: ${this.formatDateTime(now)}
; https://regattaflow.com
;
; This file can be opened in Sailwave (https://www.sailwave.com)`;
  }

  private generateSeriesSection(series: SeriesConfig): string {
    const lines = ['[series]'];
    lines.push(`sername=${this.escapeValue(series.name)}`);
    if (series.path) {
      lines.push(`serpath=${this.escapeValue(series.path)}`);
    }
    lines.push(`session=${series.session || 1}`);
    return lines.join('\n');
  }

  private generateEventSection(event: EventConfig): string {
    const lines = ['[event]'];
    lines.push(`evtname=${this.escapeValue(event.name)}`);
    lines.push(`evtstart=${this.formatDate(event.startDate)}`);
    lines.push(`evtend=${this.formatDate(event.endDate)}`);
    lines.push(`evtvenue=${this.escapeValue(event.venue)}`);
    lines.push(`evtorgclub=${this.escapeValue(event.organizingClub)}`);
    if (event.boatClass) {
      lines.push(`evtclass=${this.escapeValue(event.boatClass)}`);
    }
    if (event.notes) {
      lines.push(`evtnotes=${this.escapeValue(event.notes)}`);
    }
    return lines.join('\n');
  }

  private generateScoringSection(scoring: ScoringConfig): string {
    const lines = ['[scoring]'];
    lines.push(`scrcode=${scoring.systemCode}`);
    lines.push(`scrname=${this.escapeValue(scoring.systemName)}`);
    lines.push(`scrdnfvalue=${scoring.dnfValue}`);
    lines.push(`scrdncvalue=${scoring.dncValue}`);
    lines.push(`scrdsqvalue=${scoring.dsqValue}`);
    lines.push(`scrdnevalue=${scoring.dneValue}`);
    lines.push(`scrocs=${scoring.ocsValue}`);
    lines.push(`scrzfp=${scoring.zfpPenalty}`);
    lines.push(`scrbfd=${scoring.bfdValue}`);
    if (scoring.ufpValue) {
      lines.push(`scrufp=${scoring.ufpValue}`);
    }
    lines.push(`scrscp=${scoring.scpPenalty}`);
    if (scoring.retValue) {
      lines.push(`scrret=${scoring.retValue}`);
    }
    if (scoring.rafValue) {
      lines.push(`scrraf=${scoring.rafValue}`);
    }
    return lines.join('\n');
  }

  private generateDiscardSection(discards: number[]): string {
    const lines = ['[discard]'];
    lines.push(`discards=${discards.join(',')}`);
    return lines.join('\n');
  }

  private generateFleetSection(fleet: { id: number; name: string }): string {
    const lines = ['[fleet]'];
    lines.push(`fleetid=${fleet.id}`);
    lines.push(`fleetname=${this.escapeValue(fleet.name)}`);
    return lines.join('\n');
  }

  private generateDivisionSection(division: { id: number; name: string }): string {
    const lines = ['[division]'];
    lines.push(`divisionid=${division.id}`);
    lines.push(`divisionname=${this.escapeValue(division.name)}`);
    return lines.join('\n');
  }

  private generateCompetitorSection(comp: Competitor): string {
    const lines = ['[comp]'];
    lines.push(`compid=${comp.id}`);
    lines.push(`compsailno=${this.escapeValue(comp.sailNumber)}`);

    if (comp.boatClass) {
      lines.push(`compclass=${this.escapeValue(comp.boatClass)}`);
    }
    if (comp.fleet !== undefined) {
      lines.push(`compfleet=${comp.fleet}`);
    }
    if (comp.division) {
      lines.push(`compdivision=${this.escapeValue(comp.division)}`);
    }

    lines.push(`comphelmname=${this.escapeValue(comp.helmName)}`);

    if (comp.crewName) {
      lines.push(`compcrewname=${this.escapeValue(comp.crewName)}`);
    }
    if (comp.club) {
      lines.push(`compclub=${this.escapeValue(comp.club)}`);
    }
    if (comp.nationality) {
      lines.push(`compnat=${comp.nationality}`);
    }
    if (comp.rating !== undefined) {
      lines.push(`comprating=${comp.rating}`);
    }
    if (comp.ratingSystem) {
      lines.push(`compratingsystem=${comp.ratingSystem}`);
    }
    if (comp.excluded) {
      lines.push(`compexclude=1`);
    }
    if (comp.notes) {
      lines.push(`compnotes=${this.escapeValue(comp.notes)}`);
    }

    return lines.join('\n');
  }

  private generateRaceSection(race: Race): string {
    const lines = ['[race]'];
    lines.push(`raceid=${race.id}`);
    lines.push(`racedate=${this.formatDate(race.date)}`);

    if (race.time) {
      lines.push(`racetime=${race.time}`);
    }

    lines.push(`racename=${this.escapeValue(race.name)}`);
    lines.push(`racerank=${race.rank}`);
    lines.push(`racestatus=${this.mapRaceStatusToSailwave(race.status)}`);

    if (race.notes) {
      lines.push(`racenotes=${this.escapeValue(race.notes)}`);
    }
    if (race.windConditions) {
      lines.push(`racewind=${this.escapeValue(race.windConditions)}`);
    }
    if (race.windDirection !== undefined) {
      lines.push(`racewinddir=${race.windDirection}`);
    }
    if (race.windSpeed !== undefined) {
      lines.push(`racewindspeed=${race.windSpeed}`);
    }
    if (race.fleet !== undefined) {
      lines.push(`racefleet=${race.fleet}`);
    }

    return lines.join('\n');
  }

  private generateResultSection(result: RaceResult): string {
    const lines = ['[raceresult]'];
    lines.push(`rrid=${result.id}`);
    lines.push(`rrrace=${result.raceId}`);
    lines.push(`rrcompetitor=${result.competitorId}`);

    if (result.position !== undefined) {
      lines.push(`rrpos=${result.position}`);
    }
    if (result.elapsedTime) {
      lines.push(`rrelapsed=${result.elapsedTime}`);
    }
    if (result.correctedTime) {
      lines.push(`rrcorrected=${result.correctedTime}`);
    }
    if (result.statusCode) {
      lines.push(`rrcode=${result.statusCode}`);
    }

    lines.push(`rrpts=${result.points}`);

    if (result.notes) {
      lines.push(`rrnotes=${this.escapeValue(result.notes)}`);
    }
    if (result.penalty) {
      lines.push(`rrpenalty=${result.penalty}`);
    }
    if (result.penaltyPercent !== undefined) {
      lines.push(`rrpenaltypercent=${result.penaltyPercent}`);
    }
    if (result.redress) {
      lines.push(`rrredress=1`);
    }
    if (result.redressPosition !== undefined) {
      lines.push(`rrredresspos=${result.redressPosition}`);
    }

    return lines.join('\n');
  }

  private generateRawSection(section: BLWSection): string {
    const lines = [`[${section.type}]`];
    for (const [key, value] of Object.entries(section.data)) {
      lines.push(`${key}=${value}`);
    }
    return lines.join('\n');
  }

  // ==========================================================================
  // Private Methods - Formatting Helpers
  // ==========================================================================

  private formatDate(date: Date): string {
    if (!date || isNaN(date.getTime())) {
      date = new Date();
    }
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    return `${day}/${month}/${year}`; // European format
  }

  private formatDateTime(date: Date): string {
    const dateStr = this.formatDate(date);
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    return `${dateStr} ${hours}:${minutes}`;
  }

  private mapRaceStatusToSailwave(status: Race['status']): string {
    const map: Record<Race['status'], string> = {
      sailed: 'sailed',
      abandoned: 'abandoned',
      cancelled: 'cancelled',
      scheduled: '',
    };
    return map[status] || '';
  }

  private escapeValue(value: string): string {
    if (!value) return '';
    // BLW format doesn't have complex escaping, but we should
    // handle any newlines or special characters
    return value
      .replace(/\r\n/g, ' ')
      .replace(/\n/g, ' ')
      .replace(/\r/g, ' ');
  }
}

// Export singleton instance
export const blwGenerator = new BLWGenerator();

