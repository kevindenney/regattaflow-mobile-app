/**
 * MCP Client Service
 *
 * Manages connection to the RegattaFlow MCP server and provides
 * convenient methods for accessing resources and tools.
 */

import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

export interface MCPServerConfig {
  command: string;
  args?: string[];
  env?: Record<string, string>;
}

export class MCPClientService {
  private client: Client | null = null;
  private transport: StdioClientTransport | null = null;
  private connected = false;

  /**
   * Connect to the MCP server
   */
  async connect(config: MCPServerConfig): Promise<void> {
    if (this.connected) {
      console.log('‚ö†Ô∏è MCP client already connected');
      return;
    }

    try {
      console.log('üîå Connecting to MCP server...');

      // Create transport
      this.transport = new StdioClientTransport({
        command: config.command,
        args: config.args || [],
        env: config.env || {},
      });

      // Create client
      this.client = new Client({
        name: 'regattaflow-client',
        version: '1.0.0',
      });

      // Connect
      await this.client.connect(this.transport);
      this.connected = true;

      console.log('‚úÖ MCP client connected successfully');
    } catch (error) {
      console.error('‚ùå Failed to connect to MCP server:', error);
      throw error;
    }
  }

  /**
   * Disconnect from the MCP server
   */
  async disconnect(): Promise<void> {
    if (!this.connected) {
      return;
    }

    try {
      if (this.client) {
        await this.client.close();
      }
      this.connected = false;
      console.log('üîå MCP client disconnected');
    } catch (error) {
      console.error('‚ùå Error disconnecting MCP client:', error);
      throw error;
    }
  }

  /**
   * List available resources from MCP server
   */
  async listResources(): Promise<any[]> {
    this.ensureConnected();

    try {
      const response = await this.client!.request(
        { method: 'resources/list' },
        {}
      );

      return response.resources || [];
    } catch (error) {
      console.error('‚ùå Failed to list MCP resources:', error);
      throw error;
    }
  }

  /**
   * Read a specific resource
   */
  async readResource(uri: string): Promise<any> {
    this.ensureConnected();

    try {
      const response = await this.client!.request(
        { method: 'resources/read' },
        { uri }
      );

      return response.contents?.[0];
    } catch (error) {
      console.error(`‚ùå Failed to read resource ${uri}:`, error);
      throw error;
    }
  }

  /**
   * List available tools from MCP server
   */
  async listTools(): Promise<any[]> {
    this.ensureConnected();

    try {
      const response = await this.client!.request(
        { method: 'tools/list' },
        {}
      );

      return response.tools || [];
    } catch (error) {
      console.error('‚ùå Failed to list MCP tools:', error);
      throw error;
    }
  }

  /**
   * Call a tool on the MCP server
   */
  async callTool(name: string, args: Record<string, any>): Promise<any> {
    this.ensureConnected();

    try {
      const response = await this.client!.request(
        { method: 'tools/call' },
        { name, arguments: args }
      );

      return response;
    } catch (error) {
      console.error(`‚ùå Failed to call tool ${name}:`, error);
      throw error;
    }
  }

  /**
   * Get current weather data
   */
  async getCurrentWeather(): Promise<any> {
    const data = await this.readResource('weather://current');
    return JSON.parse(data.text);
  }

  /**
   * Get active races
   */
  async getActiveRaces(): Promise<any[]> {
    const data = await this.readResource('races://active');
    return JSON.parse(data.text);
  }

  /**
   * Get tidal predictions for a location
   */
  async getTidalPredictions(location: string): Promise<any[]> {
    const data = await this.readResource(`tides://prediction/${location}`);
    return JSON.parse(data.text);
  }

  /**
   * Get bathymetry data for a venue
   */
  async getBathymetryData(venueId: string): Promise<any> {
    const data = await this.readResource(`bathymetry://venue/${venueId}`);
    return JSON.parse(data.text);
  }

  /**
   * Get boat polar data
   */
  async getBoatPolars(boatClass: string): Promise<any> {
    const data = await this.readResource(`boats://polars/${boatClass}`);
    return JSON.parse(data.text);
  }

  /**
   * Get race course data
   */
  async getRaceCourse(raceId: string): Promise<any> {
    const data = await this.readResource(`courses://race/${raceId}`);
    return JSON.parse(data.text);
  }

  /**
   * Analyze race start line
   */
  async analyzeStartLine(params: {
    raceId: string;
    windDirection: number;
    windSpeed: number;
    currentDirection?: number;
    currentSpeed?: number;
  }): Promise<any> {
    const result = await this.callTool('analyze_start_line', params);
    return JSON.parse(result.content[0].text);
  }

  /**
   * Analyze tidal opportunities
   */
  async analyzeTidalOpportunities(params: {
    raceId: string;
    startTime: string;
    duration: number;
    location: string;
  }): Promise<any> {
    const result = await this.callTool('analyze_tidal_opportunities', params);
    return JSON.parse(result.content[0].text);
  }

  /**
   * Calculate optimal route
   */
  async calculateOptimalRoute(params: {
    startLat: number;
    startLon: number;
    endLat: number;
    endLon: number;
    windDirection: number;
    windSpeed: number;
    currentDirection?: number;
    currentSpeed?: number;
    boatClass?: string;
  }): Promise<any> {
    const result = await this.callTool('calculate_optimal_route', params);
    return JSON.parse(result.content[0].text);
  }

  /**
   * Analyze performance from GPS track
   */
  async analyzePerformance(params: {
    trackId: string;
    boatClass: string;
    compareToPolars?: boolean;
  }): Promise<any> {
    const result = await this.callTool('analyze_performance', params);
    return JSON.parse(result.content[0].text);
  }

  /**
   * Check if client is connected
   */
  isConnected(): boolean {
    return this.connected;
  }

  /**
   * Ensure client is connected before making requests
   */
  private ensureConnected(): void {
    if (!this.connected || !this.client) {
      throw new Error('MCP client is not connected. Call connect() first.');
    }
  }
}

// Export singleton instance
export const mcpClientService = new MCPClientService();
